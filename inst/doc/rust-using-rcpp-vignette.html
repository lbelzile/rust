<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Paul Northrop" />

<meta name="date" content="2017-05-25" />

<title>Rusting faster: Simulation using Rcpp</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Rusting faster: Simulation using Rcpp</h1>
<h4 class="author"><em>Paul Northrop</em></h4>
<h4 class="date"><em>2017-05-25</em></h4>


<div id="TOC">
<ul>
<li><a href="#providing-a-c-function-to-ru_rcpp">Providing a C++ function to <code>ru_rcpp</code></a></li>
<li><a href="#examples-ru_rcpp">Examples : <code>ru_rcpp</code></a><ul>
<li><a href="#standard-normal-density">Standard normal density</a></li>
<li><a href="#mvn">Multivariate normal density</a></li>
<li><a href="#log-normal-density-after-box-cox-transformation">Log-normal density after Box-Cox transformation</a></li>
<li><a href="#generalized-pareto-posterior-density">Generalized Pareto posterior density</a></li>
</ul></li>
<li><a href="#examples-find_lambda_rcpp_one_d-and-find_lambda_rcpp">Examples : <code>find_lambda_rcpp_one_d</code> and <code>find_lambda_rcpp</code></a><ul>
<li><a href="#gamma-density-example-for-find_lambda_one_d">Gamma density: example for <code>find_lambda_one_d</code></a></li>
<li><a href="#generalized-pareto-posterior-density-example-for-find_lambda">Generalized Pareto posterior density: example for <code>find_lambda</code></a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<p>The <strong>rust</strong> package implements the multivariate generalized ratio-of-uniforms method of simulating random variates from a <span class="math inline">\(d\)</span>-dimensional continuous distribution. For an introduction to <em>rust</em> see the vignette <a href="rust-vignette.html">Introducing rust</a>. The user specifies (the log of) a positive target function <span class="math inline">\(f(x)\)</span> that is proportional to the density function of the distribution.</p>
<p>This vignette describes a new feature of <strong>rust</strong>: the option for the user to provide a C++ function to evaluate the target log-density, rather than an R function. The <strong>Rcpp</strong> <span class="citation">(Eddelbuettel and Francois 2011, <span class="citation">Eddelbuettel (2013)</span>)</span> and <strong>RcppArmadillo</strong> <span class="citation">(Eddelbuettel and Sanderson 2014)</span> packages are used to speed up simulation from the target density. The improvement results from faster function evaluations and (in particular) from performing using C++ the looping in the ratio-of-uniforms algorithm. The new function <code>ru_rcpp</code> requires the target log-density to be specified using (externals pointers to) C++ functions, whereas the existing <code>ru</code> requires input R functions. Otherwise, the functionality of these two functions is the same. There are also Rcpp-based versions of functionsfor setting Box-Cox transformation parameters: <code>find_lambda_rcpp</code> and <code>find_lambda_one_d_rcpp</code></p>
<p>In this vignette we describe in general terms the general setup of the Rcpp-based functions and use examples to illustrate their use. For more information about these examples see the vignette <a href="rust-vignette.html">Introducing rust</a></p>
<div id="providing-a-c-function-to-ru_rcpp" class="section level2">
<h2>Providing a C++ function to <code>ru_rcpp</code></h2>
<p>The general way that <strong>rust</strong> enables users to provide their own C++ functions uses external pointers and is based on the <a href="http://gallery.rcpp.org/">Rcpp Gallery</a> article <a href="http://gallery.rcpp.org/articles/passing-cpp-function-pointers/">Passing user-supplied C++ functions</a> by Dirk Eddelbuettel. For a detailed case study of the general approach see the <strong>RcppDE</strong> package <span class="citation">(Eddelbuettel 2016)</span> vignette at the <a href="https://CRAN.R-project.org/package=RcppDE">RcppDE page on CRAN</a>.</p>
<p>The user writes a C++ function to calculate <span class="math inline">\(\log f(x)\)</span>. The current implementation in <strong>rust</strong> requires this function to have a particular structure: it must take a constant reference to an <code>Rcpp::NumericVector</code>, say <code>x</code>, a constant reference to an <code>Rcpp::List</code>, say <code>pars</code>, and return a <code>double</code> precision scalar. <code>x</code> is the argument <span class="math inline">\(x\)</span> of <span class="math inline">\(f(x)\)</span>. <code>pars</code> is a list containing the values of parameters whose values are not specified inside the function. This allows the user to change the values of any parameters in the target density without editing the function. If there are no such parameters then the user must still include the argument <code>pars</code> in their function, even though the list provided to the function when it is called will be empty.</p>
<p>A simple way for the user provide their C++ functions to create them in a file, say <code>user_fns.cpp</code>. Example content of this file is provided below. The full file is available on the <a href="https://github.com/paulnorthrop/rust/blob/master/src/user_fns.cpp">rust Github page</a>. The functions in this file are compiled and made available to R, either using the <code>Rcpp::sourceCpp</code> function (e.g. <code>Rcpp::sourceCpp(&quot;user_fns.cpp&quot;)</code>) or using RStudio’s Source button on the editor toolbar. The example content below also includes the function <code>create_xptr</code>, which creates an external pointer to a C++ function. See . It is this external pointer that is passed to <code>ru_rcpp</code> to perform ratio-of-uniforms sampling. If the user has written a C++ function, say <code>new_name</code>, they need to add to <code>create_xptr</code> two lines of code:</p>
<pre><code>else if (fstr == &quot;new_name&quot;)  
  return(Rcpp::XPtr&lt;funcPtr&gt;(new funcPtr(&amp;new_name))) ;</code></pre>
<p>in order that they can create an external pointer for <code>new_name</code> using <code>create_xptr</code>. The following example of file <code>user_fns.cpp</code> contains code for a standard normal density. Note that for this particular example we don’t need RcppArmadillo: we could replace <code>#include &lt;RcppArmadillo.h&gt;</code> with <code>#include &lt;Rcpp.h&gt;</code> and delete <code>using namespace arma;</code>. However, RcppArmadillo is used in the the <a href="#mvn">multivariate normal example</a> below and will be useful in many examples.</p>
<pre><code>// [[Rcpp::depends(RcppArmadillo)]]

#include &lt;RcppArmadillo.h&gt;

using namespace arma;
using namespace Rcpp;

// [[Rcpp::interfaces(r, cpp)]]

// User-supplied C++ functions for logf.

// Note that currently the only interface available in rust is
// double fun(const Rcpp::NumericVector&amp; x, const Rcpp::List&amp; pars).
// However, as shown in the function logdmvnorm below RcppArmadillo
// functions can be used inside the function.

// Each function must be prefaced by the line: // [[Rcpp::export]]

// One-dimensional standard normal.

// [[Rcpp::export]]  
double logdN01(const Rcpp::NumericVector&amp; x, const Rcpp::List&amp; pars) {  
  return (-pow(x[0], 2.0) / 2.0) ;
}

// A function to create external pointers for any of the functions above.  
// See http://gallery.rcpp.org/articles/passing-cpp-function-pointers/  
// If you write a new function above called new_name then add the following
//
// else if (fstr == &quot;new_name&quot;)  
//   return(Rcpp::XPtr&lt;funcPtr&gt;(new funcPtr(&amp;new_name))) ;  

// [[Rcpp::export]]  
SEXP create_xptr(std::string fstr) {  
  typedef double (*funcPtr)(const Rcpp::NumericVector&amp; x,  
                  const Rcpp::List&amp; pars) ;  
  if (fstr == &quot;logdN01&quot;)  
    return(Rcpp::XPtr&lt;funcPtr&gt;(new funcPtr(&amp;logdN01))) ;  
  else  
    return(Rcpp::XPtr&lt;funcPtr&gt;(R_NilValue)) ;  
}  

// We could create the external pointers when this file is sourced using   
// the embedded R code below and/or (re)create them using create_xptr() in 
// an R session or R package..

/*** R
ptr_N01 &lt;- create_xptr(&quot;logdN01&quot;)
*/</code></pre>
</div>
<div id="examples-ru_rcpp" class="section level2">
<h2>Examples : <code>ru_rcpp</code></h2>
<p>All the examples in the documentation for <code>ru</code> are replicated in the documentation for <code>ru_rcpp</code>. Here we consider a subset of the examples from the <a href="rust-vignette.html">Introducing rust</a> vignette, to illustrate how to provide user-supplied C++ functions to <code>ru_rcpp</code> and to compare the performances of <code>ru</code> and <code>ru_rcpp</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rust)
<span class="kw">library</span>(Rcpp)
<span class="kw">library</span>(RcppArmadillo)
<span class="kw">library</span>(microbenchmark)
<span class="co"># Set the size of the simulated sample</span>
n &lt;-<span class="st"> </span><span class="dv">1000</span></code></pre></div>
<p>It is assumed that the user has already compiled their C++ functions and made them available to their R session, either using the <code>Rcpp::sourceCpp</code> function (e.g. <code>Rcpp::sourceCpp(&quot;user_fns.cpp&quot;)</code>) or using RStudio’s Source button on the editor toolbar.</p>
<div id="standard-normal-density" class="section level3">
<h3>Standard normal density</h3>
<p>We start with a simple example: the (1-dimensional) standard normal density, based on the C++ function <code>logdN01</code> in the example <code>user_fns.cpp</code> file above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Normal density ===================</span>

<span class="co"># Create a pointer to the logdN01 C++ function</span>
<span class="co"># (not necessary if this was created when the file of C++ functions was sourced)</span>
ptr_N01 &lt;-<span class="st"> </span><span class="kw">create_xptr</span>(<span class="st">&quot;logdN01&quot;</span>)

<span class="co"># Use ru and ru_rcpp starting from the same random number seed and check</span>
<span class="co"># that the simulated values are the same.</span>
<span class="kw">set.seed</span>(<span class="dv">47</span>)
x_old &lt;-<span class="st"> </span><span class="kw">ru</span>(<span class="dt">logf =</span> function(x) -x ^<span class="st"> </span><span class="dv">2</span> /<span class="st"> </span><span class="dv">2</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> <span class="fl">0.1</span>)
<span class="kw">head</span>(x_old$sim_vals)
<span class="co">#&gt;            [,1]</span>
<span class="co">#&gt; [1,]  0.7764728</span>
<span class="co">#&gt; [2,]  0.5310434</span>
<span class="co">#&gt; [3,] -0.1046049</span>
<span class="co">#&gt; [4,]  1.2111509</span>
<span class="co">#&gt; [5,]  1.1391379</span>
<span class="co">#&gt; [6,]  0.5180914</span>
<span class="kw">set.seed</span>(<span class="dv">47</span>)
x_new &lt;-<span class="st"> </span><span class="kw">ru_rcpp</span>(<span class="dt">logf =</span> ptr_N01, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> <span class="fl">0.1</span>)
<span class="kw">head</span>(x_new$sim_vals)
<span class="co">#&gt;            [,1]</span>
<span class="co">#&gt; [1,]  0.7764728</span>
<span class="co">#&gt; [2,]  0.5310434</span>
<span class="co">#&gt; [3,] -0.1046049</span>
<span class="co">#&gt; [4,]  1.2111509</span>
<span class="co">#&gt; [5,]  1.1391379</span>
<span class="co">#&gt; [6,]  0.5180914</span>

<span class="co"># Compare performances of ru and ru_rcpp</span>
res &lt;-<span class="st"> </span><span class="kw">microbenchmark</span>(
 <span class="dt">old =</span> <span class="kw">ru</span>(<span class="dt">logf =</span> function(x) -x ^<span class="st"> </span><span class="dv">2</span> /<span class="st"> </span><span class="dv">2</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> <span class="fl">0.1</span>),
 <span class="dt">new =</span> <span class="kw">ru_rcpp</span>(<span class="dt">logf =</span> ptr_N01, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> <span class="fl">0.1</span>)
)
<span class="kw">print</span>(res, <span class="dt">signif =</span> <span class="dv">4</span>)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;  expr    min     lq      mean median     uq     max neval</span>
<span class="co">#&gt;   old 33.470 36.610 41.537590 40.790 42.820 162.600   100</span>
<span class="co">#&gt;   new  2.604  2.751  3.086832  2.925  3.024   7.219   100</span></code></pre></div>
<p>As we would hope, <code>ru_rcpp</code> is faster than <code>ru</code>. If we start from the same random number seed we get the same simulated values from <code>ru</code> and <code>ru_rcpp</code>.</p>
</div>
<div id="mvn" class="section level3">
<h3>Multivariate normal density</h3>
<p>To execute this example we add the following function to <code>user_fns.cpp</code></p>
<pre><code>// d-dimensional normal with zero-mean and covariance matrix sigma.

// [[Rcpp::export]]
double logdmvnorm(const Rcpp::NumericVector&amp; x, const Rcpp::List&amp; pars) {
  arma::mat sigma = as&lt;arma::mat&gt;(pars[&quot;sigma&quot;]) ;
  arma::vec y = Rcpp::as&lt;arma::vec&gt;(x) ;
  double qform = arma::as_scalar(y.t() * arma::inv(sigma) * y) ;
  return -qform / 2.0  ;
}</code></pre>
<p>and add</p>
<pre><code>else if (fstr == &quot;logdmvnorm&quot;)
  return(Rcpp::XPtr&lt;funcPtr&gt;(new funcPtr(&amp;logdmvnorm))) ;</code></pre>
<p>to the function <code>create_xptr</code> in <code>user_fns.cpp</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Three-dimensional normal with positive association ----------------</span>
rho &lt;-<span class="st"> </span><span class="fl">0.9</span>
covmat &lt;-<span class="st"> </span><span class="kw">matrix</span>(rho, <span class="dv">3</span>, <span class="dv">3</span>) +<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span> -<span class="st"> </span>rho, <span class="dv">3</span>)
<span class="co"># R function</span>
log_dmvnorm &lt;-<span class="st"> </span>function(x, <span class="dt">mean =</span> <span class="kw">rep</span>(<span class="dv">0</span>, d), <span class="dt">sigma =</span> <span class="kw">diag</span>(d)) {
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(x, <span class="dt">ncol =</span> <span class="kw">length</span>(x))
  d &lt;-<span class="st"> </span><span class="kw">ncol</span>(x)
  -<span class="st"> </span><span class="fl">0.5</span> *<span class="st"> </span>(x -<span class="st"> </span>mean) %*%<span class="st"> </span><span class="kw">solve</span>(sigma) %*%<span class="st"> </span><span class="kw">t</span>(x -<span class="st"> </span>mean)
}
<span class="co"># Create a pointer to the logdmvnorm C++ function</span>
ptr_mvn &lt;-<span class="st"> </span><span class="kw">create_xptr</span>(<span class="st">&quot;logdmvnorm&quot;</span>)

res &lt;-<span class="st"> </span><span class="kw">microbenchmark</span>(
  <span class="dt">old =</span> <span class="kw">ru</span>(<span class="dt">logf =</span> log_dmvnorm, <span class="dt">sigma =</span> covmat, <span class="dt">d =</span> <span class="dv">3</span>, <span class="dt">n =</span> n,
           <span class="dt">init =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)), 
  <span class="dt">new =</span> <span class="kw">ru_rcpp</span>(<span class="dt">logf =</span> ptr_mvn, <span class="dt">sigma =</span> covmat, <span class="dt">d =</span> <span class="dv">3</span>, <span class="dt">n =</span> n,
                <span class="dt">init =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))
)  
<span class="kw">print</span>(res, <span class="dt">signif =</span> <span class="dv">4</span>)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;  expr     min      lq      mean median    uq    max neval</span>
<span class="co">#&gt;   old 234.600 262.100 274.51402 272.60 285.5 401.40   100</span>
<span class="co">#&gt;   new   8.975   9.908  10.96687  10.34  10.7  20.44   100</span></code></pre></div>
<p>Again, the improvement in speed obtained using Rcpp is clear.</p>
</div>
<div id="log-normal-density-after-box-cox-transformation" class="section level3">
<h3>Log-normal density after Box-Cox transformation</h3>
<p>In this example we use a log transform (Box-Cox parameter <span class="math inline">\(\lambda = 0\)</span>) so that the ratio-of-uniforms sampling is based on a normal distribution. The C++ function to calculate the log-density of a lognormal distribution is:</p>
<pre><code>// Lognormal(mu, sigma).

// [[Rcpp::export]]
double logdlnorm(const Rcpp::NumericVector&amp; x, const Rcpp::List&amp; pars) {
  double mu = pars[&quot;mu&quot;] ;
  double sigma = pars[&quot;sigma&quot;] ;
  if (x[0] &gt; 0)
    return -log(x[0]) - pow(log(x[0]) - mu, 2.0) / (2.0 * pow(sigma, 2.0)) ;
  else
    return R_NegInf ;
}</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ptr_lnorm &lt;-<span class="st"> </span><span class="kw">create_xptr</span>(<span class="st">&quot;logdlnorm&quot;</span>)
res &lt;-<span class="st"> </span><span class="kw">microbenchmark</span>(
 <span class="dt">old =</span> <span class="kw">ru</span>(<span class="dt">logf =</span> dlnorm, <span class="dt">log =</span> <span class="ot">TRUE</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n, <span class="dt">lower =</span> <span class="dv">0</span>, <span class="dt">init =</span> <span class="fl">0.1</span>,
          <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>, <span class="dt">lambda =</span> <span class="dv">0</span>),
 <span class="dt">new =</span> <span class="kw">ru_rcpp</span>(<span class="dt">logf =</span> ptr_lnorm, <span class="dt">mu =</span> <span class="dv">0</span>, <span class="dt">sigma =</span> <span class="dv">1</span>, <span class="dt">d =</span> <span class="dv">1</span>, <span class="dt">n =</span> n,
               <span class="dt">lower =</span> <span class="dv">0</span>, <span class="dt">init =</span> <span class="fl">0.1</span>, <span class="dt">trans =</span> <span class="st">&quot;BC&quot;</span>, <span class="dt">lambda =</span> <span class="dv">0</span>)
)
<span class="kw">print</span>(res, <span class="dt">signif =</span> <span class="dv">4</span>)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;  expr    min     lq      mean median    uq   max neval</span>
<span class="co">#&gt;   old 49.360 55.270 57.269187  56.75 59.74 64.89   100</span>
<span class="co">#&gt;   new  4.848  5.127  6.053989   5.24  5.36 81.24   100</span></code></pre></div>
</div>
<div id="generalized-pareto-posterior-density" class="section level3">
<h3>Generalized Pareto posterior density</h3>
<p>The C++ function to calculate the log-posterior density is:</p>
<pre><code>// Generalized Pareto posterior based on an MDI prior truncated to
// shape parameter xi &gt;= -1.

// [[Rcpp::export]]
double loggp(const Rcpp::NumericVector&amp; x, const Rcpp::List&amp; ss) {
  Rcpp::NumericVector gpd_data = ss[&quot;gpd_data&quot;] ;
  int m = ss[&quot;m&quot;] ;
  double xm = ss[&quot;xm&quot;] ;
  double sum_gp = ss[&quot;sum_gp&quot;] ;
  if (x[0] &lt;= 0 || x[1] &lt;= -x[0] / xm)
    return R_NegInf ;
  double loglik ;
  Rcpp::NumericVector sdat = gpd_data / x[0] ;
  Rcpp::NumericVector zz = 1 + x[1] * sdat ;
  if (std::abs(x[1]) &gt; 1e-6) {
    loglik = -m * log(x[0]) - (1.0 + 1.0 / x[1]) * sum(log(zz)) ;
  } else {
    double t1, t2, sdatj ;
    double total = 0;
    for(int j = 0; j &lt; m; ++j) {
      sdatj = sdat[j] ;
      for(int i = 1; i &lt; 5; ++i) {
        t1 = pow(sdatj, i) ;
        t2 = (i * sdatj - i - 1) ;
        total += pow(-1, i) * t1 * t2 * pow(x[1], i) / i / (i + 1) ;
      }
    }
    loglik = -m * log(x[0]) - sum_gp / x[0] - total ;
  }
  // MDI prior.
  if (x[1] &lt; -1)
    return R_NegInf ;
  double logprior = -log(x[0]) - x[1] - 1 ;
  return (logprior + loglik) ;
}</code></pre>
<p>We simulate some data from a Generalized Pareto distribution, calculate summary statistics involved in the likelihood and calculate an initial value in the search for the posterior mode.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">46</span>)
<span class="co"># Sample data from a GP(sigma, xi) distribution</span>
gpd_data &lt;-<span class="st"> </span><span class="kw">rgpd</span>(<span class="dt">m =</span> <span class="dv">100</span>, <span class="dt">xi =</span> -<span class="fl">0.5</span>, <span class="dt">sigma =</span> <span class="dv">1</span>)
<span class="co"># Calculate summary statistics for use in the log-likelihood</span>
ss &lt;-<span class="st"> </span><span class="kw">gpd_sum_stats</span>(gpd_data)
<span class="co"># Calculate an initial estimate</span>
init &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">mean</span>(gpd_data), <span class="dv">0</span>)</code></pre></div>
<p>Again we see that <code>ru_rcpp</code> is substantially faster than <code>ru</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Arguments for ru_rcpp</span>
ptr_gp &lt;-<span class="st"> </span><span class="kw">create_xptr</span>(<span class="st">&quot;loggp&quot;</span>)
for_ru_rcpp &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">list</span>(<span class="dt">logf =</span> ptr_gp, <span class="dt">init =</span> init, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n,
                 <span class="dt">lower =</span> <span class="kw">c</span>(<span class="dv">0</span>, -<span class="ot">Inf</span>)), ss)

res &lt;-<span class="st"> </span><span class="kw">microbenchmark</span>(
 <span class="dt">old =</span> <span class="kw">ru</span>(<span class="dt">logf =</span> gpd_logpost, <span class="dt">ss =</span> ss, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">n =</span> n, <span class="dt">init =</span> init,
          <span class="dt">lower =</span> <span class="kw">c</span>(<span class="dv">0</span>, -<span class="ot">Inf</span>)),
 <span class="dt">new =</span> <span class="kw">do.call</span>(ru_rcpp, for_ru_rcpp)
)
<span class="kw">print</span>(res, <span class="dt">signif =</span> <span class="dv">4</span>)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;  expr    min     lq      mean median     uq    max neval</span>
<span class="co">#&gt;   old 145.40 150.90 156.37649  153.6 157.30 267.50   100</span>
<span class="co">#&gt;   new  18.08  18.94  20.45427   19.4  22.67  25.85   100</span></code></pre></div>
</div>
</div>
<div id="examples-find_lambda_rcpp_one_d-and-find_lambda_rcpp" class="section level2">
<h2>Examples : <code>find_lambda_rcpp_one_d</code> and <code>find_lambda_rcpp</code></h2>
<p>We repeat two examples from the <a href="rust-vignette.html">Introducing rust</a> vignette.</p>
<div id="gamma-density-example-for-find_lambda_one_d" class="section level3">
<h3>Gamma density: example for <code>find_lambda_one_d</code></h3>
<p>We make use of the <a href="https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-sugar.pdf">Rcpp sugar</a> function <code>dgamma</code>.</p>
<pre><code>// Gamma(alpha, 1).

// [[Rcpp::export]]
double logdgamma(const Rcpp::NumericVector&amp; x, const Rcpp::List&amp; pars) {
  double shp = pars[&quot;alpha&quot;] ;
  return Rcpp::dgamma(x, shp, 1.0, 1)[0] ;
}</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">alpha &lt;-<span class="st"> </span><span class="dv">1</span>
max_phi &lt;-<span class="st"> </span><span class="kw">qgamma</span>(<span class="fl">0.999</span>, <span class="dt">shape =</span> alpha)
ptr_gam &lt;-<span class="st"> </span><span class="kw">create_xptr</span>(<span class="st">&quot;logdgamma&quot;</span>)
lambda &lt;-<span class="st"> </span><span class="kw">find_lambda_one_d_rcpp</span>(<span class="dt">logf =</span> ptr_gam, <span class="dt">alpha =</span> alpha,
                                 <span class="dt">max_phi =</span> max_phi)
lambda
<span class="co">#&gt; $lambda</span>
<span class="co">#&gt; [1] 0.2719394</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $gm</span>
<span class="co">#&gt; [1] 0.5686779</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $init_psi</span>
<span class="co">#&gt; [1] -0.2015393</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $sd_psi</span>
<span class="co">#&gt; [1] 0.7820847</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $user_args</span>
<span class="co">#&gt; list()</span></code></pre></div>
</div>
<div id="generalized-pareto-posterior-density-example-for-find_lambda" class="section level3">
<h3>Generalized Pareto posterior density: example for <code>find_lambda</code></h3>
<p>In this example we supply an external pointer to a C++ function <code>phi_to_theta</code> that ensures that both parameters of the model are strictly positive, a requirement for the Box-Cox transformation to be applicable. See the <a href="rust-vignette.html">Introducing rust</a> vignette for the form of transformation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">temp &lt;-<span class="st"> </span><span class="kw">do.call</span>(gpd_init, ss)
min_phi &lt;-<span class="st"> </span><span class="kw">pmax</span>(<span class="dv">0</span>, temp$init_phi -<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span>temp$se_phi)
max_phi &lt;-<span class="st"> </span><span class="kw">pmax</span>(<span class="dv">0</span>, temp$init_phi +<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span>temp$se_phi)

<span class="co"># Create external pointers</span>
ptr_gp &lt;-<span class="st"> </span><span class="kw">create_xptr</span>(<span class="st">&quot;loggp&quot;</span>)
ptr_phi_to_theta_gp &lt;-<span class="st"> </span><span class="kw">create_phi_to_theta_xptr</span>(<span class="st">&quot;gp&quot;</span>)
<span class="co"># Note: log_j is set to zero by default inside find_lambda_rcpp()</span>
lambda &lt;-<span class="st"> </span><span class="kw">find_lambda_rcpp</span>(<span class="dt">logf =</span> ptr_gp, <span class="dt">ss =</span> ss, <span class="dt">d =</span> <span class="dv">2</span>, <span class="dt">min_phi =</span> min_phi,
                           <span class="dt">max_phi =</span> max_phi, <span class="dt">user_args =</span> <span class="kw">list</span>(<span class="dt">xm =</span> ss$xm),
                           <span class="dt">phi_to_theta =</span> ptr_phi_to_theta_gp)
lambda
<span class="co">#&gt; $lambda</span>
<span class="co">#&gt; [1] 0.1624226 0.3678549</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $gm</span>
<span class="co">#&gt; [1] 1.10542493 0.03225836</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $init_psi</span>
<span class="co">#&gt; [1]  0.1054021 -0.2184344</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $sd_psi</span>
<span class="co">#&gt;       Var1       Var2 </span>
<span class="co">#&gt; 0.12670792 0.02477219 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $phi_to_theta</span>
<span class="co">#&gt; &lt;pointer: 0x000000000860dec0&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $log_j</span>
<span class="co">#&gt; &lt;pointer: 0x000000000860dd40&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $user_args</span>
<span class="co">#&gt; $user_args$xm</span>
<span class="co">#&gt; [1] 1.846219</span></code></pre></div>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-RcppDEbook">
<p>Eddelbuettel, D. 2013. <em>Seamless R and C++ Integration with Rcpp</em>. New York: Springer.</p>
</div>
<div id="ref-RcppDE">
<p>———. 2016. <em>RcppDE: Global Optimization by Differential Evolution in C++</em>. <a href="https://CRAN.R-project.org/package=RcppDE" class="uri">https://CRAN.R-project.org/package=RcppDE</a>.</p>
</div>
<div id="ref-Rcpp">
<p>Eddelbuettel, D., and R. Francois. 2011. “Rcpp: Seamless R and C++ Integration.” <em>Journal of Statistical Software</em> 40 (8): 1–18. doi:<a href="https://doi.org/10.18637/jss.v040.i08">10.18637/jss.v040.i08</a>.</p>
</div>
<div id="ref-arma">
<p>Eddelbuettel, D., and C. Sanderson. 2014. “RcppArmadillo: Accelerating R with High-Performance C++ Linear Algebra.” <em>Computational Statistics and Data Analysis</em> 71: 1054–63. doi:<a href="https://doi.org/10.1016/j.csda.2013.02.005">10.1016/j.csda.2013.02.005</a>.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
